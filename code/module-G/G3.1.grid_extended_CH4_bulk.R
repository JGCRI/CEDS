# ------------------------------------------------------------------------------
# Program Name: G3.1.grid_extended_CH4_bulk.R
# Author(s): Leyang Feng
# Date Last Updated: Jun 27, 2017
# Program Purpose: Grid aggregated emissions into NetCDF grids for bulk emissions (excluding AIR)
# Input Files: MED_OUT: CEDS_[em]_emissions_by_country_CEDS_sector_[CEDS_version].csv
# Output Files: INT_OUT: CEDS_[em]_anthro_[year]_0.5_[CEDS_version].nc; CEDS_[em]_anthro_[year]_0.5_[CEDS_version].csv
#               DIAG_OUT: CEDS_[em]_anthro_[year]_TOTAL_0.5_[CEDS_version].nc; CEDS_[em]_anthro_[year]_TOTAL_0.5_[CEDS_version].csv
#                         CEDS_[em]_anthro_[year]_TOTAL_monthly_[CEDS_version].nc; CEDS_[em]_anthro_[year]_TOTAL_monthly_[CEDS_version].csv
#                         G.[em]_bulk_emissions_checksum_comparison_diff.csv
#                         G.[em]_bulk_emissions_checksum_comparison_per.csv
# Notes:
# TODO: find smarter way to deal with missing int sector grids in int_grids_list
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# 0. Read in global settings and headers
# Define PARAM_DIR as the location of the CEDS "parameters" directory, relative
# to the "input" directory.
    PARAM_DIR <- "../code/parameters/"

# Call standard script header function to read in universal header files -
# provides logging, file support, and system functions - and start the script log.
  headers <- c( 'gridding_functions.R', 'data_functions.R', 'nc_generation_functions.R' ) # Any additional function files required
  log_msg <- "Gridding extended CH4 anthropogenic emissions (excluding AIR) " # First message to be printed to the log
  script_name <- "G3.1.grid_extended_CH4_bulk.R"

  source( paste0( PARAM_DIR, "header.R" ) )
  initialize( script_name, log_msg, headers )

# ------------------------------------------------------------------------------
# 0.5 Initialize gridding setups
# Define emissions species variable
  args_from_makefile <- commandArgs( TRUE )
  em <- args_from_makefile[ 1 ]
  if ( is.na( em ) ) em <- "CH4"
  em_lc <- tolower( em )

  MODULE_G <- "../code/module-G/"

  output_dir <- filePath( 'MED_OUT', 'gridded-emissions/', extension = "" )
  total_grid_dir <- filePath( 'DIAG_OUT', 'total-emissions-grids/', extension = "" )
  proxy_dir <- filePath( "GRIDDING", "", extension = "", domain_extension = "proxy/" )
  proxy_backup_dir <- filePath( "GRIDDING", "", extension = "", domain_extension = "proxy_backup/")
  mask_dir <- filePath( "GRIDDING", "", extension = "", domain_extension = "mask/")
  seasonality_dir <- filePath( "GRIDDING", "", extension = "", domain_extension = "seasonality/" )
	final_emissions_dir <- filePath( "FIN_OUT", "", extension = "", domain_extension = "current-versions/" )

  gridding_initialize( grid_resolution = 0.5,
                       start_year = 1850,
                       end_year = 1960,
                       load_masks = T,
                       load_seasonality_profile = T )
# override the year list generated by gridding_initialize
  year_list <- seq( 1850, 1970, 10 )

# ------------------------------------------------------------------------------
# 1. Read in files

# read in the emission data
  target_filename <- 'H.CH4_RCP_Back-Extended'
  emissions <- readData( "MED_OUT", domain_extension = "", target_filename )

# read in some mapping files
  location_index <- readData( "GRIDDING", domain_extension = "gridding_mappings/", file_name =  "country_location_index_05" )
  ceds_gridding_mapping <- readData( 'GRIDDING', domain_extension = 'gridding_mappings/', file_name = 'CEDS_sector_to_gridding_sector_mapping' )
  proxy_mapping <- readData( domain = "GRIDDING", domain_extension = "gridding_mappings/", 'proxy_mapping' )
  seasonality_mapping <- readData( domain = "GRIDDING", domain_extension = "gridding_mappings/", 'seasonality_mapping' )
  proxy_substitution_mapping <- readData( domain = 'GRIDDING', domain_extension = "gridding_mappings/", 'proxy_subsititution_mapping' )
  sector_name_mapping <- readData( domain = 'GRIDDING', domain_extension = "gridding_mappings/", 'CEDS_gridding_sectors' )
  sector_int_list_no_air <- sort( unique( sector_name_mapping$CEDS_int_sector_short ) )
  sector_int_list_no_air <- sector_int_list_no_air[ sector_int_list_no_air != 'AIR' ]
  sector_name_mapping <- unique( sector_name_mapping[ , c( "CEDS_fin_sector", "CEDS_fin_sector_short" ) ] )

# ------------------------------------------------------------------------------
# 2. Pre-processing
# Convert the emission data from CEDS working sectors to CEDS level 1 gridding sector
  ceds_gridding_mapping_int <- ceds_gridding_mapping[ , c( 'CEDS_working_sector', 'CEDS_int_gridding_sector_short' ) ]
  gridding_emissions <- merge( emissions, ceds_gridding_mapping_int, by.x = 'sector', by.y = 'CEDS_working_sector' )
# drop non-matched sectors
  gridding_emissions <- gridding_emissions[ !is.na( gridding_emissions$CEDS_int_gridding_sector_short ), ]
# aggregate the emissions at gridding sectors
  gridding_emissions <- aggregate( gridding_emissions[ , paste0( 'X', year_list ) ],
                                   by = list( gridding_emissions$iso, gridding_emissions$CEDS_int_gridding_sector_short ),
                                   FUN = sum )
# change column names
  colnames( gridding_emissions ) <- c( 'iso', 'sector', paste0( 'X', year_list ) )
# remove AIR sector in data
  gridding_emissions <- gridding_emissions[ !gridding_emissions$sector == 'AIR', ]

# ------------------------------------------------------------------------------
# 3. Gridding and writing output data
# For now, the gridding routine uses nested for loops to go through every years
# gases and sectors. May consider to take away for loop for sectors and keep year loops
# for future parallelization
  printLog( paste0( 'Start ', em, ' gridding for each year ' ) )

    for ( year in year_list ) {

      int_grids_list <- grid_one_year( em,
                                       year,
                                       grid_resolution,
                                       gridding_emissions,
                                       location_index,
                                       proxy_mapping,
                                       proxy_substitution_mapping )
      for ( int_sector in sector_int_list_no_air ) {
        if ( paste0( int_sector, '_int_grid' ) %!in% names( int_grids_list ) ) {
          int_grids_list[[ paste0( int_sector, '_int_grid' ) ]] <- matrix( 0, 180/grid_resolution, 360/grid_resolution )
          }

      }
      generate_final_grids_nc( int_grids_list,
                               output_dir,
                               grid_resolution,
                               year,
                               em,
                               sector_name_mapping,
                               seasonality_mapping )
      generate_annual_total_emissions_grids_nc( total_grid_dir,
                                                int_grids_list,
                                                grid_resolution,
                                                year,
                                                em )
      generate_monthly_total_emissions_grids_nc( total_grid_dir,
                                                 int_grids_list,
                                                 grid_resolution,
                                                 year,
                                                 em,
                                                 seasonality_mapping )

    }
# -----------------------------------------------------------------------------
# 4. Checksum
    printLog( 'Start checksum check' )

    ceds_gridding_mapping_fin <- ceds_gridding_mapping[ , c( 'CEDS_int_gridding_sector_short', 'CEDS_final_gridding_sector_short' ) ]
    ceds_gridding_mapping_fin <- unique( ceds_gridding_mapping_fin )
    gridding_emissions_fin <- merge( gridding_emissions, ceds_gridding_mapping_fin,
                                     by.x = 'sector', by.y = 'CEDS_int_gridding_sector_short', all.x = T )
    gridding_emissions_fin <- aggregate( gridding_emissions_fin[ paste0( 'X', year_list ) ],
                                         by = list( gridding_emissions_fin$CEDS_final_gridding_sector_short ),
                                         FUN = sum )
    colnames( gridding_emissions_fin ) <- c( 'sector', paste0( 'X', year_list ) )
    gridding_emissions_fin <- gridding_emissions_fin[ order( gridding_emissions_fin$sector ), ]

    checksum_file_list <- list.files( path = output_dir, pattern = paste0( '_', em, '_anthro' ) )
    checksum_file_list <- grep( '.csv', checksum_file_list, fixed = T, value = T )
    checksum_res_list <- lapply( checksum_file_list, function( file_name ) {
      temp_csv <- read.csv( paste0( output_dir, file_name  ) )
      } )
    checksum_df <- do.call( 'rbind', checksum_res_list )
    checksum_df <- aggregate( checksum_df$value, by = list( checksum_df$sector, checksum_df$year ), FUN = sum  )
    colnames( checksum_df ) <- c( 'sector', 'year', 'value' )
    checksum_df <- cast( checksum_df, sector ~ year )
    colnames( checksum_df ) <- c( 'sector', paste0( 'X', year_list ) )
    checksum_df <- checksum_df[ order( checksum_df$sector ), ]

    diag_diff_df <- cbind( checksum_df$sector, abs( gridding_emissions_fin[ paste0( 'X', year_list ) ] - checksum_df[ paste0( 'X', year_list ) ] ) )
    diag_per_df <- cbind( checksum_df$sector, ( diag_diff_df[ paste0( 'X', year_list ) ] / gridding_emissions_fin[ paste0( 'X', year_list ) ] ) * 100 )
    diag_per_df[ is.na( diag_per_df ) ] <- NA

# -----------------------------------------------------------------------------
# 5. Write-out and Stop
    out_name <- paste0( 'G.', em, '_extended_bulk_emissions_checksum_comparison_diff' )
    writeData( diag_diff_df, "DIAG_OUT", out_name )
    out_name <- paste0( 'G.', em, '_extended_bulk_emissions_checksum_comparison_per' )
    writeData( diag_per_df, "DIAG_OUT", out_name )

# Every script should finish with this line:
logStop()
