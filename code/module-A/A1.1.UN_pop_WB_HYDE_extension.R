#------------------------------------------------------------------------------
# Program Name: A1.1.UN_pop_WB_HYDE_extension.R
# Author: Linh Vu, Rachel Hoesly, Patrick O'Rourke
# Date Last Updated: June 7, 2019
# Program Purpose: Produce input population data for CEDS emissions system from
#                  United Nations data, World Bank (WB) data, and the History
#                  Database of the Global Environment (HYDE) data.
#                  Output are 1700-2100 population and urban population share.
# Input Files: WPP2015_POP_F01_1_TOTAL_POPULATION_BOTH_SEXES.XLS;
#              WUP2014-F21-Proportion_Urban_Annual.xls;
#              WB_SP.POP.TOTL.csv; WB_SP.URB.TOTL.csv;
#              urbanpop_2004Rev_tcm61-36007.xlsx; Master_Country_List.csv
#              UN_pop_WB_HYDE_ext_iso_map.xlsx; UN_pop_shares_WB_HYDE_ext_iso_map.xlsx;
#              WB_pop_UN_HYDE_ext_iso_map.xlsx; HYDE_pop_UN_WB_ext_iso_map.xlsx
# Output Files: A.UN_pop_master.csv; A.HYDE_pop.csv; A.UN_pop_WB_ext.csv; A.UN_WB_vs_HYDE_1950. csv
# Notes: 1. UN population data are downloaded from:
#           -- Total population: http://esa.un.org/unpd/wpp/DVD/
#           -- Urban population share: http://esa.un.org/unpd/wup/CD-ROM/
#           WB population and urban population share can optionally be pulled from the
#           WDI API, using the R package FAOSTAT.
#        2. UN has population data for 1950-2100, urban share data for 1950-2050.
#           WB has population and urban share data for 1960-2014. HYDE has population
#           and urban share data for 1700-2030.
#           -- UN urban shares for 2051-2100 are linearly extrapolated from 2050
#           share and 2049-2050 growth rate.
#           -- HYDE 1700-1950 data are available every 10 years -- linearly
#           interpolate for all years in between.
#           -- HYDE has population for West Bank & Gaza, but only urban share
#           for Gaza - currently use Gaza's urban share for West Bank & Gaza.
#           -- HYDE urban shares are > 1 in some places -- just bring down to 1.
#        3. Data priority/processing order is UN > WB > HYDE:
#        a) For 1950-2100, use WB data where UN data is unavailable:
#           -- Extrapolate WB population to all UN years using a proxy country's
#           UN population growth rate, and either use WB urban share or assume
#           proxy country's UN urban share if WB urban share unavailable.
#           -- Currently use this routine to generate Kosovo's population (Serbia
#           as proxy, assume Serbia's UN urban share).
#        b) For 1901-1949, linearly interpolate 1950 UN/WB so that it matches
#           HYDE in 1900. For 1700-1900, just use HYDE.
#           -- If no HYDE is available, extrapolate 1950 UN/WB using HYDE single
#           year-to-year ratio of a proxy country.
#        4. Population for dissolved countries are generated by summing member
#           countries' population. Population for both separate and combined
#           countries are kept.
#           -- Currently use this routine to generate population for Serbia
#           and Montenegro, Czechoslovakia, Netherlands Antilles, and
#           Belgium-Luxembourg.
# TODO: Update extendProxy() function.
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# 0. Read in global settings and headers
# Define PARAM_DIR as the location of the CEDS "parameters" directory, relative
# to the "input" directory.
    PARAM_DIR <- if("input" %in% dir()) "code/parameters/" else "../code/parameters/"

# Call standard script header function to read in universal header files -
# provide logging, file support, and system functions - and start the script log.
    headers <- c( "IO_functions.R","data_functions.R", "analysis_functions.R", "timeframe_functions.R" )
    log_msg <- "Produce population data for CEDS from UN, WB and HYDE data"
    script_name <- "A1.1.UN_pop_WB_HYDE_extension.R"

    source( paste0( PARAM_DIR, "header.R" ) )
    initialize( script_name, log_msg, headers )

    # This is the first file that is run in the system, check for correct inputs
    checkSystemInputs( commandArgs( TRUE )[1] )

# ------------------------------------------------------------------------------
# 1. Read in files and do preliminary setup

# Read UN population and urban population data
    UN_pop_raw <- readData( "GEN_IN", "WPP2015_POP_F01_1_TOTAL_POPULATION_BOTH_SEXES",
                            ".xlsx", sheet_selection = "ALL", skip = 16 )
    UN_urban_share_raw <- readData( "GEN_IN", "WUP2014-F21-Proportion_Urban_Annual",
                                    ".xlsx", sheet_selection = "ANNUAL DATA",
                                    skip = 16 )

# Read WB population and urban population data, either by pulling from the WDI API
#   or reading from directory (currently selected)
#     WB_pop_raw <- getWDI( indicator = "SP.POP.TOTL", name = "pop" ) %>%
#       filter( !is.na( pop ) )  # drop non-data rows
#     WB_urban_pop_raw <- getWDI( indicator = "SP.URB.TOTL", name = "urban_pop" ) %>%
#       filter( !is.na( urban_pop ) )  # drop non-data rows
    WB_pop_raw <- readData( "GEN_IN", "WB_SP.POP.TOTL" )
    WB_urban_pop_raw <- readData( "GEN_IN", "WB_SP.URB.TOTL" )

# Read HYDE population and urban population
    HYDE_pop_raw <- readData( "GEN_IN", "urbanpop_2004Rev_tcm61-36007", ".xlsx",
                              sheet_selection = "total numbers", skip = 2 )[ 1:233, 2:109 ]
    HYDE_urban_share_raw <- readData( "GEN_IN", "urbanpop_2004Rev_tcm61-36007", ".xlsx",
                                      sheet_selection = "% urban", skip = 1 )[ 1:233, 3:110 ]

# Read master country list
    Master_Country_List <- readData( "MAPPINGS", "Master_Country_List" )

# Read in UN, WB, HYDE iso maps
    UN_pop_WB_HYDE_ext_iso_map <- readData ( "MAPPINGS", "UN_pop_WB_HYDE_ext_iso_map", ".xlsx",
                                             sheet_selection = "UN_pop_WB_HYDE_ext_iso_map" )

    UN_pop_shares_WB_HYDE_ext_iso_map <- readData ( "MAPPINGS", "UN_pop_WB_HYDE_ext_iso_map", ".xlsx",
                                                    sheet_selection = "UN_pop_shares_WB_HYDE_ext",
                                                    missing_value = "NA" )

    WB_pop_UN_HYDE_ext_iso_map <- readData ( "MAPPINGS", "UN_pop_WB_HYDE_ext_iso_map", ".xlsx",
                                             sheet_selection = "WB_pop_UN_HYDE_ext_iso_map" )

    HYDE_pop_UN_WB_ext_iso_map <- readData ( "MAPPINGS", "UN_pop_WB_HYDE_ext_iso_map", ".xlsx",
                                             sheet_selection = "HYDE_pop_UN_WB_ext_iso_map" )

# Define standardized UN scenario names (check against Excel input)
    UN_scenarios_std <- c( "Estimates", "Medium fertility", "High fertility",
                           "Low fertility", "Constant fertility", "Instant-replacement",
                           "Zero-migration", "Constant-mortality", "No change" )

# Define UN population historical end year (last year of UN population "Estimates",
# and the first year of other 'Variant' values of UN population data).
    UN_POP_HISTORICAL_END_YEAR <- 2015

# ------------------------------------------------------------------------------
# 2. Clean up UN and WB population input
    printLog( "Processing UN, WB and HYDE population input to standard format..." )

# Prepare UN population
    # Read all population scenarios into one df
    UN_pop_raw <- lapply( seq_along( UN_pop_raw[ -1 ] ), function( i ) {

        if( i == 1 ) {

            UN_years <-  as.character ( 1950:UN_POP_HISTORICAL_END_YEAR )

        } else {

            UN_years <-  as.character( UN_POP_HISTORICAL_END_YEAR:2100 )

        }

        out <- UN_pop_raw[[ i ]] %>%
            dplyr::left_join( UN_pop_WB_HYDE_ext_iso_map,
                              by = c( "Index", "Major area, region, country or area *",
                                      "Country code" ) ) %>%
            dplyr::select( UN_CODE, ISO3_WB_CODE, "Major area, region, country or area *",
                           UN_years ) %>%
            dplyr::rename( UN_code = UN_CODE, iso = ISO3_WB_CODE, country = "Major area, region, country or area *" ) %>%
            dplyr::mutate( scenario = UN_scenarios_std[[ i ]] ) %>%
            tidyr::gather( key = year, value = value, UN_years ) %>%
            dplyr::select( UN_code, iso, scenario, country, year, value ) %>%
            dplyr::mutate( year = as.factor( year ) ) %>%
            dplyr::rename( pop = value )

        return( out )

    } )

    UN_pop_raw <- do.call( rbind, UN_pop_raw )
    UN_pop_raw$year <- as.numeric( as.character( UN_pop_raw$year ) )
    UN_pop_raw <- UN_pop_raw %>%
        dplyr::arrange( year, UN_code )

    # Read and format urban population share
    UN_years <- as.character( 1950:2050 )

    UN_urban_share_raw <- UN_urban_share_raw %>%
        dplyr::left_join( UN_pop_shares_WB_HYDE_ext_iso_map,
                          by = c( "Index", "Major area, region, country or area",
                                  "Country Code" ) ) %>%
        dplyr::select( UN_code = UN_CODE, iso = ISO3_WB_CODE, UN_years ) %>%
        dplyr::arrange( UN_code )

    names( UN_urban_share_raw )[ 1:2 ] <- c( "UN_code", "iso" )
    UN_urban_share_raw <- melt( UN_urban_share_raw, id = c( "UN_code", "iso" ),
                             variable_name = "year", na.rm = T )
    names( UN_urban_share_raw )[ names( UN_urban_share_raw ) == "value" ] <- "urban_share"
    UN_urban_share_raw$urban_share <- UN_urban_share_raw$urban_share / 100  # percent to decimal
    UN_urban_share_raw$year <- as.numeric( as.character( UN_urban_share_raw$year ) )

    # Assert that all countries with UN population have UN urban share
    stopifnot( length( setdiff( UN_pop_raw$iso, UN_urban_share_raw$iso ) ) == 0 )

    # Merge total population and urban share in one df and compute urban population
    UN_pop <- dplyr::left_join( UN_pop_raw, UN_urban_share_raw,
                                by = c( "UN_code", "iso", "year" ) ) %>%
        dplyr::mutate( urban_pop = pop * urban_share )

    # Fix missing/outdated ISO codes
    # Taiwan gets pulled from "Other non-specified areas"
    UN_pop <- UN_pop %>%
        dplyr::filter( UN_code < 900 ) %>% # skip aggregated regions
        dplyr::mutate( country = if_else( UN_code == 158, "Taiwan", country ) ) %>%
        dplyr::mutate( iso = tolower( iso ),
                       iso = if_else( UN_code == 156, "chn", iso ), # add ISO for China
                       iso = sub( "zar", "cod", iso ), # update DRC
                       iso = sub( "tmp", "tls", iso ), # update Timor-Leste
                       iso = sub( "rom", "rou", iso ), # update Romania
                       iso = sub( "ado", "and", iso ), # update Andorra
                       iso = sub( "imy", "imn", iso ) ) %>% # update Isle of Man
        dplyr::arrange( scenario, iso, year )

# Prepare WB population
    # Merge WB pop and urban pop into one df and reformat, mapped from ISO2 to ISO3
    WB_pop <- merge( WB_pop_raw, WB_urban_pop_raw, all.x = T ) %>%
        dplyr::left_join(WB_pop_UN_HYDE_ext_iso_map,
                         by = c("Country", "ISO2_WB_CODE") ) %>%
        dplyr::arrange(ISO2_WB_CODE) %>%
        dplyr::select(ISO2_WB_CODE, ISO3_WB_CODE, Country, Year, pop, urban_pop) %>%
        dplyr::select( -ISO2_WB_CODE ) %>%
        dplyr::distinct( )

    names( WB_pop ) <- c( "iso", "country", "year", "pop", "urban_pop" )
    WB_pop$iso <- tolower( WB_pop$iso )
    WB_pop$pop <- WB_pop$pop / 1000  # convert pop units to thous. people
    WB_pop$urban_pop <- WB_pop$urban_pop / 1000
    WB_pop <- dplyr::mutate( WB_pop, urban_share = urban_pop / pop )  # compute urban share
    WB_pop <- dplyr::arrange( WB_pop, iso, year )

# Prepare HYDE population
    # Bind HYDE total population and urban share into one df
    names( HYDE_pop_raw )[ names( HYDE_pop_raw ) == "Country" ] <- "COUNTRY"
    HYDE_pop_raw$type <- "pop"
    HYDE_urban_share_raw$type <- "urban_share"
    HYDE_pop <- bind_rows( HYDE_pop_raw, HYDE_urban_share_raw ) %>% data.frame( )

    # Convert UN code to ISO code (note HYDE ISO-CODE column is actually UN code)
    HYDE_ALL_YEARS <- paste0( "X" , c( seq( 1700, 1950, 10 ), 1951:2030 ) )

    HYDE_pop <- HYDE_pop %>%
        dplyr::left_join( HYDE_pop_UN_WB_ext_iso_map, by = c( "ISO.CODE", "COUNTRY" ) ) %>%
        dplyr::select( "ISO.CODE", ISO3_WB_CODE, COUNTRY, HYDE_ALL_YEARS, type ) %>%
        dplyr::arrange( ISO.CODE, type )

    names( HYDE_pop )[ 1:3 ] <- c( "UN_code", "iso", "country" )
    HYDE_pop$iso <- tolower( HYDE_pop$iso )
    HYDE_pop$iso[ HYDE_pop$UN_code == 156 ] <- "chn"  # add ISO for China
    HYDE_pop$iso[ HYDE_pop$iso == "zar" ] <- "cod"  # update ISO of Democratic Republic of Congo
    HYDE_pop$iso[ HYDE_pop$iso == "tmp" ] <- "tls"  # update ISO of Timor-Leste
    HYDE_pop$iso[ HYDE_pop$iso == "rom" ] <- "rou"  # update ISO of Romania
    HYDE_pop$iso[ HYDE_pop$iso == "ado" ] <- "and"  # update ISO of Andorra
    HYDE_pop$iso[ HYDE_pop$iso == "imy" ] <- "imn"  # update ISO of Isle of Man
    HYDE_pop$UN_code[ HYDE_pop$UN_code == 275 ] <- 274  # use Gaza data for Occupied Palestinian Territory
    HYDE_pop$iso[ HYDE_pop$UN_code == 274 ] <- "wbg"

    # HYDE are available every 10 years for 1700-1950. Linearly interpolate for all
    # years in between.
    X_HYDE_interp_years <- paste0( "X", seq( 1700, 1950, 10 ) )
    for( i_year in seq_along( X_HYDE_interp_years[ -1 ] ) ){
      HYDE_pop <- interpolate( HYDE_pop, X_HYDE_interp_years[[ i_year ]], X_HYDE_interp_years[[ i_year + 1 ]] )
    }

    # Reshape
    HYDE_pop <- HYDE_pop %>%
        dplyr::select( -country ) %>%
        tidyr::gather( year, value, -UN_code, -iso, -type ) %>%
        dplyr::mutate( year = xYearToNum( year ) ) %>%
        tidyr::spread( type, value )

    # Some countries have urban share > 100% -- bring down to 1
    HYDE_pop$urban_share <- HYDE_pop$urban_share / 100  # percent to decimal
    HYDE_pop$urban_share[ HYDE_pop$urban_share > 1 ] <- 1

# Define useful values
    WB_pop_years <- sort( unique( WB_pop_raw$Year ) )
    UN_pop_years <- sort( unique( UN_pop_raw$year ) )
    UN_urban_years <- sort( unique( UN_urban_share_raw$year ) )
    HYDE_years <- sort( unique( HYDE_pop$year ) )
    HYDE_years_to_use <- setdiff( HYDE_years, UN_pop_years )
    HYDE_comp_year <- min( intersect( UN_pop_years, HYDE_years ) )  # common year used to compare HYDE and UN/WB (1950)

# ------------------------------------------------------------------------------
# 3. Produce 1950-2100 population series from UN and WB data
    printLog( "Produce 1950-2100 population series from UN and WB data" )

# Diagnostics: What countries in Master_Country_List are missing from UN pop?
    in_MCL_not_in_UN <- setdiff( Master_Country_List$iso, UN_pop$iso )
    # srb (kosovo): generate later by proxying srb
    # ant, csk, scg, blx: historical dissolved countries -- generate later
    # pse, USSR, yug: ok to omit
    if ( length( in_MCL_not_in_UN ) > 0 ) {
      warning( "The following Master_Country_List countries do not have UN data:")
      for (i in 1:length( in_MCL_not_in_UN ) ) {
        warning( paste0( in_MCL_not_in_UN[[ i ]], ": ",
          Master_Country_List$Country_Name[ match( in_MCL_not_in_UN[[ i ]],
                                                   Master_Country_List$iso ) ] ) )
      }
    }

# Define functions to handle population generation
    # pop_list: list of population df, used for generating final population data.
    # Population-generation functions (sumPop(), extendProxy(), extendPop())
    # will append results as new elements of pop_list.
    # All pop_list elements should have the same variable list, hence the need for
    # function completeID() below.
    pop_list <- list( UN_pop )

    # completeID(): takes in single country df, adds ID columns (UN_code, iso,
    # country) and removes redundant columns (i.e. not in UN_pop); called by
    # population-generation functions: sumPop(), extendProxy(), extendPop()
    completeID <- function( df, UN_code = NA, iso = NA, country = NA ){
      df <- df[ names( df ) %in% names( UN_pop ) ]
      df <- dplyr::mutate( df, UN_code = UN_code, iso = iso, country = country )
      return( df )
    }

    # sumPop(): looks in df for countries listed in vector_of_iso and returns sum
    # of their population; used for handling dissolved countries. Results are appended
    # to pop_list.
    sumPop <- function( df, vector_of_iso, UN_code = NA, iso = NA, country = NA ) {
      # check that df has population for all member countries, listed in vector_of_iso
      member_countries <- unique( df$iso[ df$iso %in% vector_of_iso ] )
      if ( length( member_countries ) == length( vector_of_iso ) ) {
        out <- df %>%
          dplyr::filter( iso %in% vector_of_iso ) %>%
          dplyr::group_by( scenario, year ) %>%
          dplyr::summarise( pop = sum( pop ), urban_pop = sum( urban_pop ) ) %>%
          completeID( UN_code, iso, country )

        pop_list[[ length( pop_list ) + 1 ]] <<- out  # append to pop_list

        warning( "Population for ", iso,
                 " (now dissolved) is generated by summing member countries: ",
                 paste( member_countries, collapse = ' ' ) )
        return( out )
      } else {
        warning( paste( "Population for", iso, "cannot be generated" ) )
      }
    }

    # extendProxy(): takes df containing two time series (s1, s2 -- described below),
    # extends s1 using s2 growth, returns completed s1 series.
    #   s1: incomplete series, to be extended using s2 growth rate; assumed to cover
    #       a continuous range of all s2 years (e.g. 1960-2014 covers a continuous
    #       range of 1950-2100)
    #   s2: complete series, to be used as proxy for extending s1 (see example below)
    #   first_data_year: first year where s1 is available
    #   last_data_year: last year where s1 is available
    #   col_out: column name of extended s1 series
    # EXAMPLE: Say s1 is available 1960-2014 and s2 is available 1950-2100, so first_data_year
    # is 1960 and last_data_year is 2014. Then s1 will be extended to 1950-2100 as follows:
    #   s1[1959] = s1[1960] * s2[1959] / s2[1960]
    #   s1[1958] = s1[1959] * s2[1958] / s2[1959]
    #            = s1[1960] * ( s2[1959] / s2[1960] ) * ( s2[1958] / s2[1959] )
    #            = s1[1960] * s2[1958] / s2[1960]
    #   s1[1950] = s1[1960] * s2[1950] / s2[1960]
    #   s1[2100] = s1[2014] * s2[2100] / s2[2014]
    # TODO: Fix cases where first_data_year or last_data_year is 0
    extendProxy <- function( df, s1, s2, first_data_yr, last_data_yr, col_out ){
      out <- dplyr::arrange( df, year )
      out[, col_out ] <- out[, s1 ]
      for ( i_year in out$year ){
        if ( i_year < first_data_yr ){
          out[ out$year == i_year, col_out ] <- out[ out$year == first_data_yr, col_out ] *
            out[ out$year == i_year, s2 ] / out[ out$year == first_data_yr, s2 ]
        }
        if ( i_year > last_data_yr ){
          out[ out$year == i_year, col_out ] <- out[ out$year == last_data_yr, col_out ] *
            out[ out$year == i_year, s2 ] / out[ out$year == last_data_yr, s2 ]
        }
      }
      return( out )
    }

    # extendPop(): operates split-apply-combine of extendProxy() by population scenario to
    # generate population. Results are appended to pop_list.
    extendPop <- function( df, pop1, pop2, first_data_yr, last_data_yr,
                           UN_code = NA, iso = NA, country = NA ){
      # Future projection scenarios may not have base pop1 to extend from -- extract
      # last pop1 data year and bind to all scenarios
        last <- filter( df, scenario == "Estimates" ) %>%
            dplyr::filter_( paste0( "!is.na(", pop1, ")" ) ) %>%
            dplyr::filter( year == max( year ) ) %>%
            dplyr::select( -scenario ) %>%
            merge( data.frame( scenario = UN_scenarios_std ), all = T ) %>%
            dplyr::mutate( scenario = as.character( scenario ) )

        out <- dplyr::bind_rows( df, last ) %>%
            distinct( )

      # Now extend pop1 using pop2 growth, by scenario
      out <- ddply( out, .(scenario), function(x){
        extendProxy( x, pop1, pop2, first_data_yr, last_data_yr, "pop" )
      } )
      out <- completeID( out, UN_code, iso, country )

      # Remove duplicated last pop1 data year from all scenarios except Estimates
      last_yr <- unique( last$year )[[1]]
      out <- filter( out, scenario == "Estimates" | year != last_yr )

      # Append result to pop_list
      pop_list[[ length( pop_list ) + 1 ]] <<- out
      warning( paste0( pop1, " is only available ",
                       first_data_yr, "-", last_data_yr,
                       ". Remaining years are estimated using ", pop2, " growth rate." ) )
      return( out )
    }

# For Kosovo, use WB Kosovo population (1960-2014) and Serbia's pop growth to extend
# for 1950-2100. Note Kosovo has no WB urban population data, so assume Serbia's UN
# urban share.
    # Extract Kosovo from WB population, Serbia from UN population, and merge into one df
    kosovo <- filter( WB_pop, country == "Kosovo" ) %>% select( year, pop )
    names( kosovo ) <- c( "year", "kosovo_pop" )
    serbia <- filter( UN_pop, country == "Serbia" ) %>% select( scenario, year, pop, urban_share )
    names( serbia ) <- c( "scenario", "year", "serbia_pop", "urban_share" )
    serbia_kosovo <- merge( serbia, kosovo, all = T ) %>% dplyr::arrange( scenario, year )

    # Extend Kosovo population using Serbia's growth. Results are added to pop_list for
    # later binding.
    kosovo_new <- extendPop( serbia_kosovo, pop1 = "kosovo_pop", pop2 = "serbia_pop",
                             first_data_yr = min( WB_pop_years ), last_data_yr = max( WB_pop_years ),
                             country = "Kosovo", iso = "srb (kosovo)" )

# Population for historical dissolved countries (ant, csk, scg, blx) will be generated after
# adding HYDE data (step 4d)

# Create master df, with projections for now-extinct countries
    pop_master <- ldply( pop_list, rbind.fill )
    pop_master$urban_share[ is.na( pop_master$urban_share ) ] <-  # recompute urban share if needed
      pop_master$urban_pop[ is.na( pop_master$urban_share ) ] /
      pop_master$pop[ is.na( pop_master$urban_share ) ]
    pop_master$urban_pop <- NULL

# Master df now has population for 1950-2100 and urban share for 1950-2050. Extend
# urban share for 1951-2100, using 1949-1950 growth.
    # Need to extrapolate urban_share for what years?
    years_needed <- setdiff( UN_pop_years, UN_urban_years )  # 2051-2100

    # Routine below is for right (future) extrapolation. Left (historical)
    # extrapolation is similar -- just add later if necessary.
      # Separate rows with urban_share and rows with no urban_share
    done <- filter( pop_master, !is.na( urban_share ) )
    needed <- filter( pop_master, is.na( urban_share ) )

      # Filter out the two edge years
    urban_growth <- done %>%
        dplyr::filter( year >= min( years_needed ) - 2 ) %>%
        dplyr::select( iso, year, scenario, urban_share ) %>%
        dplyr::arrange( iso, scenario, year )

      # Compute growth of UN urban_share in two edge years for each country
      # Note growth will be NA if both edge years have 0 urban share, in which
      # case make growth 0 to keep urban share at 0 in future years
    urban_growth <- urban_growth %>%
        dplyr::group_by( iso, scenario ) %>%
        dplyr::mutate( growth = urban_share / lag( urban_share ) ) %>%
        dplyr::ungroup() %>%
        dplyr::filter( year == min( years_needed ) - 1 ) %>%
        dplyr::mutate( growth = if_else( is.na( growth ), 0, growth ) ) %>%
        dplyr::rename( base_year = year, base_urban_share = urban_share )

      # Extend urban_share to all UN years, using base year share and growth
      # in the two edge years
    needed <- needed %>%
        dplyr::left_join( urban_growth, by = c( 'iso', 'scenario') ) %>%
        dplyr::mutate( urban_share = base_urban_share * growth^( year - base_year ) ) %>%
        dplyr::select( -base_year, -base_urban_share, -growth )

      # If urban_share > 1, bring down to 1
    needed$urban_share[ needed$urban_share > 1 ] <- 1

    # Bind original and extended data in one df
    pop_master_ext <- bind_rows( done, needed ) %>%
      dplyr::arrange( iso, scenario, year )


# ------------------------------------------------------------------------------
# 4. Add HYDE data to produce 1700-2100 series and generate population for historical
# dissolved countries
# -- For 1901-1949, linearly interpolate 1950 UN/WB so that it matches HYDE in
#    1900. For 1700-1900, just use HYDE data.
# -- For countries without HYDE, scale back 1950 UN/WB using HYDE trends of a proxy
#    country, as follows:
#         Curacao (cuw), Sint Maarten (sxm): use Netherlands Antilles (ant) as proxy
#         Montenegro (mne), Serbia (srb), Kosovo (srb (kosovo)): use Serbia and Montenegro
#                                                              (scg) as proxy
#         South Sudan (ssd): use Sudan (sdn) as proxy
#         Caribbean Netherlands (bes): use Netherlands Antilles (ant) as proxy
#         Mayotte (myt): use Comoros (com) ax proxy
# Note Palestine (pse) population/urban share is unavailable in all 3 datasets.

    printLog( "Add HYDE data to produce 1700-2100 population series" )

# Define constant values used in routine
    MIN_MASTER_OVER_HYDE <- .5  # threshold values for comparing
    MAX_MASTER_OVER_HYDE <- 2   # 1950 HYDE and UN/WB (for diagnostics only)
    CONVERGENCE_YEAR <- 1900    # what year to converge UN/WB to HYDE

# Add rows for HYDE years (1700-1949) to master df under scenario 'Estimates'
    HYDE_years_to_use <- setdiff( HYDE_years, pop_master_ext$year )
    HYDE_rows <- pop_master_ext %>%
        dplyr::select( UN_code, iso, country ) %>%
        dplyr::distinct() %>%
        tidyr::crossing( data.frame( year = HYDE_years_to_use,
                                     scenario = "Estimates",
                                     stringsAsFactors = F ) )
    pop_master_HYDE <- bind_rows( pop_master_ext, HYDE_rows ) %>%
      dplyr::arrange( scenario, iso, year )

# Add columns for HYDE population and urban shares to master df
    pop_master_HYDE <- pop_master_HYDE %>%
        dplyr::left_join( dplyr::select( HYDE_pop, iso, year,  pop_HYDE = pop,
                                         urban_share_HYDE = urban_share ),
                          by = c( 'iso', 'year' ) )

# Diagnostics: Compare 1950 population and urban share of HYDE and UN/WB
    # Compare 1950 numbers
    master_comp <- filter( pop_master_HYDE, year == HYDE_comp_year ) %>% select( iso, year, pop, urban_share )
    names( master_comp ) <- c( "iso", "year", "master_pop", "master_urban_share" )
    HYDE_comp <- filter( HYDE_pop, year == HYDE_comp_year ) %>% select( iso, year, pop, urban_share )
    names( HYDE_comp ) <- c( "iso", "year", "HYDE_pop", "HYDE_urban_share" )
    diag.master_vs_HYDE_comp <- merge( master_comp, HYDE_comp ) %>%
      dplyr::mutate( master_over_HYDE_pop = master_pop / HYDE_pop,
              master_over_HYDE_urban_share = master_urban_share / HYDE_urban_share )

    # Ratio is NA if values in HYDE and master df are both 0. Correct this ratio to 1.
    diag.master_vs_HYDE_comp$master_over_HYDE_pop[ diag.master_vs_HYDE_comp$master_pop ==
                                                     diag.master_vs_HYDE_comp$HYDE_pop ] <- 1
    diag.master_vs_HYDE_comp$master_over_HYDE_urban_share[ diag.master_vs_HYDE_comp$master_urban_share ==
                                                             diag.master_vs_HYDE_comp$HYDE_urban_share ] <- 1

    # Flag countries where master df and HYDE differs significantly
    diag.master_vs_HYDE_comp <- dplyr::mutate( diag.master_vs_HYDE_comp, flag_pop = master_over_HYDE_pop < MIN_MASTER_OVER_HYDE |
                                          master_over_HYDE_pop > MAX_MASTER_OVER_HYDE,
                                        flag_urban_share = master_over_HYDE_urban_share < MIN_MASTER_OVER_HYDE |
                                          master_over_HYDE_urban_share > MAX_MASTER_OVER_HYDE )

# 4a. For 1700-1900 (before CONVERGENCE_YEAR), just use HYDE data.
    pop_master_HYDE_a <- pop_master_HYDE
    pop_master_HYDE_a$pop[ pop_master_HYDE$year <= CONVERGENCE_YEAR ] <-
      pop_master_HYDE_a$pop_HYDE[ pop_master_HYDE$year <= CONVERGENCE_YEAR ]
    pop_master_HYDE_a$urban_share[ pop_master_HYDE$year <= CONVERGENCE_YEAR ] <-
      pop_master_HYDE_a$urban_share_HYDE[ pop_master_HYDE$year <= CONVERGENCE_YEAR ]


# 4b. For 1901-1949, linearly interpolate 1950 UN/WB so that it matches HYDE in 1900
#   Formula: POP(yr) = POP(hyde) + 1950Delta * (yr - 1900)/(1950-1900)
    pop_master_HYDE_b <- pop_master_HYDE_a

    # Interpolate population
    scaled <- filter( pop_master_HYDE_b, year <= HYDE_comp_year )
    scaled <- ddply( scaled, .(iso), function( df ){
      within( df, {
        pop[ year >= CONVERGENCE_YEAR & year < HYDE_comp_year ] <-
          pop_HYDE[ year >= CONVERGENCE_YEAR & year < HYDE_comp_year ] +
          ( pop[ year == HYDE_comp_year ] - pop_HYDE[ year == HYDE_comp_year ] ) *
          ( year[ year >= CONVERGENCE_YEAR & year < HYDE_comp_year ] - CONVERGENCE_YEAR ) /
          ( HYDE_comp_year - CONVERGENCE_YEAR )
        } )
    } )
    pop_master_HYDE_b <- bind_rows( filter( pop_master_HYDE_b, year > HYDE_comp_year ),
                                    scaled )

    # Interpolate urban share
    scaled <- filter( pop_master_HYDE_b, year <= HYDE_comp_year )
    scaled <- ddply( scaled, .(iso), function( df ){
      within( df, {
        urban_share[ year >= CONVERGENCE_YEAR & year < HYDE_comp_year ] <-
          urban_share_HYDE[ year >= CONVERGENCE_YEAR & year < HYDE_comp_year ] +
          ( urban_share[ year == HYDE_comp_year ] - urban_share_HYDE[ year == HYDE_comp_year ] ) *
          ( year[ year >= CONVERGENCE_YEAR & year < HYDE_comp_year ] - CONVERGENCE_YEAR ) /
          ( HYDE_comp_year - CONVERGENCE_YEAR )
      } )
    } )
    pop_master_HYDE_b <- bind_rows( filter( pop_master_HYDE_b, year > HYDE_comp_year ),
                                    scaled )


# 4c. For countries without HYDE, scale back 1950 UN/WB (population and urban share)
#   using HYDE trends of a proxy country
    pop_master_HYDE_c <- pop_master_HYDE_b

# Diagnostics: What pop_master/Master_Country_List countries do not have HYDE?
    iso_no_HYDE <- setdiff( union( pop_master$iso, Master_Country_List$iso ), HYDE_pop$iso )
    # bes, cuw, mne, myt, srb, ssd, sxm, srb (kosovo): generate later by proxying a similar country
    # csk, blx: historical dissolved countries -- generate later
    # pse, USSR, yug: ok to omit
    if ( length( iso_no_HYDE ) > 0 ) {
      warning( "The following countries do not have HYDE data:")
      for (i in 1:length( iso_no_HYDE ) ) {
        warning( paste0( iso_no_HYDE[[ i ]], ": ",
                         Master_Country_List$Country_Name[ match( iso_no_HYDE[[ i ]],
                                                                  Master_Country_List$iso ) ] ) )
      }
    }

# Make a mapping of countries without HYDE and their proxy countries
    map_proxy <- data.frame( iso_no_HYDE = c( "bes", "cuw", "mne", "myt", "srb",
                                              "ssd", "sxm", "srb (kosovo)" ),
                             iso_proxy = c( "ant", "ant", "scg", "com", "scg",
                                            "sdn", "ant", "scg" ) )

# Scale 1950 UN/WB for 1700-1949, using HYDE trends of proxy country
    scaled <- filter( pop_master_HYDE_c, iso %in% iso_no_HYDE,
                      year %in% c( HYDE_years_to_use, HYDE_comp_year ) ) %>%
      merge( select( map_proxy, iso = iso_no_HYDE, iso_proxy ), all.x = T ) %>%
      merge( select( HYDE_pop, iso_proxy = iso, year, pop_proxy = pop,
                     urban_share_proxy = urban_share ), all.x = T ) %>%
      ddply( .(iso), function( df ){
        extendProxy( df, "pop", "pop_proxy", HYDE_comp_year, HYDE_comp_year, "pop" ) %>%
        extendProxy( "urban_share", "urban_share_proxy", HYDE_comp_year,
                     HYDE_comp_year, "urban_share" )
      } )

# Bind with 1950-2100 and add urban population column
    pop_master_HYDE_c <- bind_rows(
      filter( pop_master_HYDE_c, !( iso %in% iso_no_HYDE & year %in%
                                      c( HYDE_years_to_use, HYDE_comp_year ) ) ),
      scaled ) %>%
      dplyr::mutate( urban_pop = pop*urban_share )


# 4d. Generage population for historical dissolved countries by summing member countries
#   before dissolution:
#       Czechoslovakia = Czech + Slovakia
#       Serbia and Montenegro = Serbia + Montenegro
#       Netherlands Antilles = Aruba + Curacao + Sint Maarten
#       Belgium-Luxembourg = Belgium + Luxembourg
    pop_list <- list( pop_master_HYDE_c )
    csk <- sumPop( pop_master_HYDE_c, c( "cze", "svk" ), UN_code = 200, iso = "csk",
                   country = "Czechoslovakia" )
    scg <- sumPop( pop_master_HYDE_c, c( "mne", "srb" ), UN_code = 891, iso = "scg",
                   country = "Serbia and Montenegro" )
    ant <- sumPop( pop_master_HYDE_c, c( "abw", "cuw", "sxm" ), UN_code = 530, iso = "ant",
                   country = "Netherlands Antilles" )
    blx <- sumPop( pop_master_HYDE_c, c( "bel", "lux" ), UN_code = 58, iso = "blx",
                   country = "Belgium-Luxembourg" )

    # Bind in new population
    pop_master_HYDE_d <- ldply( pop_list, rbind.fill )
    pop_master_HYDE_d$urban_share[ is.na( pop_master_HYDE_d$urban_share ) ] <-  # recompute urban share if needed
      pop_master_HYDE_d$urban_pop[ is.na( pop_master_HYDE_d$urban_share ) ] /
      pop_master_HYDE_d$pop[ is.na( pop_master_HYDE_d$urban_share ) ]


# 4e. Create final dataset
    pop_master_final <- pop_master_HYDE_d %>%
      dplyr::select( iso, UN_code, country, scenario, year, pop, urban_share ) %>%
      dplyr::arrange( iso, scenario, year )

    # Assert that there is no NA pop or urban_share left
    stopifnot( !anyNA( pop_master_final$pop ) )
    stopifnot( !anyNA( pop_master_final$urban_share ) )

    pop_master_final[ is.na( pop_master_final ) ] <- ""

    pop_master_final <- pop_master_final %>%
        dplyr::arrange(iso, scenario, year)

# 4f. Create data with one time series into future with no duplicate years
    population_data_historical <- subset( pop_master_final, scenario %in% c("Estimates") )

    max_year <- as.numeric( max( population_data_historical$year ) )
    population_data_cleaned <- subset( pop_master_final, scenario %in% c("Estimates","Medium fertility") )

    # Remove duplicate year data where historical estimates and projections overlap
    population_data_cleaned <- population_data_cleaned %>%
                              filter( !(year == max_year & scenario == "Medium fertility") )

# ------------------------------------------------------------------------------
# 5. Write output
    writeData( population_data_cleaned, "MED_OUT", "A.UN_pop_master" )

# Write diagnostics
    writeData( HYDE_pop, "DIAG_OUT", "A.HYDE_pop" )
    writeData( pop_master_ext, "DIAG_OUT", "A.UN_pop_WB_ext" )
    writeData( diag.master_vs_HYDE_comp, "DIAG_OUT", "A.UN_WB_vs_HYDE_1950" )

# Every script should finish with this line
    logStop()

# END
