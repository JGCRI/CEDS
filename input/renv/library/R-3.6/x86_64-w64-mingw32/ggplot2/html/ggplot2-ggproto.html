<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Base ggproto classes for ggplot2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for ggplot2-ggproto {ggplot2}"><tr><td>ggplot2-ggproto {ggplot2}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Base ggproto classes for ggplot2</h2>

<h3>Description</h3>

<p>If you are creating a new geom, stat, position, or scale in another package,
you'll need to extend from <code>ggplot2::Geom</code>, <code>ggplot2::Stat</code>,
<code>ggplot2::Position</code>, or <code>ggplot2::Scale</code>.
</p>


<h3>Geoms</h3>

<p>All <code style="white-space: pre;">geom_*()</code> functions (like <code>geom_point()</code>) return a layer that
contains a <code style="white-space: pre;">Geom*</code> object (like <code>GeomPoint</code>). The <code style="white-space: pre;">Geom*</code>
object is responsible for rendering the data in the plot.
</p>
<p>Each of the <code style="white-space: pre;">Geom*</code> objects is a <code><a href="ggproto.html">ggproto()</a></code> object, descended
from the top-level <code>Geom</code>, and each implements various methods and
fields.
</p>
<p>Compared to <code>Stat</code> and <code>Position</code>, <code>Geom</code> is a little
different because the execution of the setup and compute functions is
split up. <code>setup_data</code> runs before position adjustments, and
<code>draw_layer()</code> is not run until render time, much later.
</p>
<p>To create a new type of Geom object, you typically will want to
override one or more of the following:
</p>

<ul>
<li><p> Either <code>draw_panel(self, data, panel_params, coord)</code> or
<code>draw_group(self, data, panel_params, coord)</code>. <code>draw_panel</code> is
called once per panel, <code>draw_group</code> is called once per group.
</p>
<p>Use <code>draw_panel</code> if each row in the data represents a
single element. Use <code>draw_group</code> if each group represents
an element (e.g. a smooth, a violin).
</p>
<p><code>data</code> is a data frame of scaled aesthetics.
</p>
<p><code>panel_params</code> is a set of per-panel parameters for the
<code>coord</code>. Generally, you should consider <code>panel_params</code>
to be an opaque data structure that you pass along whenever you call
a coord method.
</p>
<p>You must always call <code>coord$transform(data, panel_params)</code> to
get the (position) scaled data for plotting. To work with
non-linear coordinate systems, you typically need to convert into a
primitive geom (e.g. point, path or polygon), and then pass on to the
corresponding draw method for munching.
</p>
<p>Must return a grob. Use <code><a href="zeroGrob.html">zeroGrob()</a></code> if there's nothing to
draw.
</p>
</li>
<li> <p><code>draw_key</code>: Renders a single legend key.
</p>
</li>
<li> <p><code>required_aes</code>: A character vector of aesthetics needed to
render the geom.
</p>
</li>
<li> <p><code>default_aes</code>: A list (generated by <code><a href="aes.html">aes()</a></code> of
default values for aesthetics.
</p>
</li>
<li> <p><code>setup_data</code>: Converts width and height to xmin and xmax,
and ymin and ymax values. It can potentially set other values as well.
</p>
</li></ul>



<h3>Coordinate systems</h3>

<p>All <code style="white-space: pre;">coord_*()</code> functions (like <code>coord_trans()</code>) return a <code style="white-space: pre;">Coord*</code>
object (like <code>CoordTrans</code>).
</p>
<p>Each of the <code style="white-space: pre;">Coord*</code> objects is a <code><a href="ggproto.html">ggproto()</a></code> object,
descended from the top-level <code>Coord</code>.  To create a new type of Coord
object, you typically will want to implement one or more of the following:
</p>

<ul>
<li> <p><code>aspect</code>: Returns the desired aspect ratio for the plot.
</p>
</li>
<li> <p><code>labels</code>: Returns a list containing labels for x and y.
</p>
</li>
<li> <p><code>render_fg</code>: Renders foreground elements.
</p>
</li>
<li> <p><code>render_bg</code>: Renders background elements.
</p>
</li>
<li> <p><code>render_axis_h</code>: Renders the horizontal axes.
</p>
</li>
<li> <p><code>render_axis_v</code>: Renders the vertical axes.
</p>
</li>
<li> <p><code>backtransform_range(panel_params)</code>: Extracts the panel range provided
in <code>panel_params</code> (created by <code>setup_panel_params()</code>, see below) and
back-transforms to data coordinates. This back-transformation can be needed
for coords such as <code>coord_trans()</code> where the range in the transformed
coordinates differs from the range in the untransformed coordinates. Returns
a list of two ranges, <code>x</code> and <code>y</code>, and these correspond to the variables
mapped to the <code>x</code> and <code>y</code> aesthetics, even for coords such as <code>coord_flip()</code>
where the <code>x</code> aesthetic is shown along the y direction and vice versa.
</p>
</li>
<li> <p><code>range(panel_params)</code>: Extracts the panel range provided
in <code>panel_params</code> (created by <code>setup_panel_params()</code>, see below) and
returns it. Unlike <code>backtransform_range()</code>, this function does not perform
any back-transformation and instead returns final transformed coordinates. Returns
a list of two ranges, <code>x</code> and <code>y</code>, and these correspond to the variables
mapped to the <code>x</code> and <code>y</code> aesthetics, even for coords such as <code>coord_flip()</code>
where the <code>x</code> aesthetic is shown along the y direction and vice versa.
</p>
</li>
<li> <p><code>transform</code>: Transforms x and y coordinates.
</p>
</li>
<li> <p><code>distance</code>: Calculates distance.
</p>
</li>
<li> <p><code>is_linear</code>: Returns <code>TRUE</code> if the coordinate system is
linear; <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>is_free</code>: Returns <code>TRUE</code> if the coordinate system supports free
positional scales; <code>FALSE</code> otherwise.
</p>
</li>
<li> <p><code>setup_panel_params(scale_x, scale_y, params)</code>: Determines the appropriate
x and y ranges for each panel, and also calculates anything else needed to
render the panel and axes, such as tick positions and labels for major
and minor ticks. Returns all this information in a named list.
</p>
</li>
<li> <p><code>setup_data(data, params)</code>: Allows the coordinate system to
manipulate the plot data. Should return list of data frames.
</p>
</li>
<li> <p><code>setup_layout(layout, params)</code>: Allows the coordinate
system to manipulate the <code>layout</code> data frame which assigns
data to panels and scales.
</p>
</li></ul>



<h3>Facets</h3>

<p>All <code style="white-space: pre;">facet_*</code> functions returns a <code>Facet</code> object or an object of a
<code>Facet</code> subclass. This object describes how to assign data to different
panels, how to apply positional scales and how to lay out the panels, once
rendered.
</p>
<p>Extending facets can range from the simple modifications of current facets,
to very laborious rewrites with a lot of <code><a href="../../gtable/html/gtable.html">gtable()</a></code> manipulation.
For some examples of both, please see the extension vignette.
</p>
<p><code>Facet</code> subclasses, like other extendible ggproto classes, have a range
of methods that can be modified. Some of these are required for all new
subclasses, while other only need to be modified if need arises.
</p>
<p>The required methods are:
</p>

<ul>
<li> <p><code>compute_layout</code>: Based on layer data compute a mapping between
panels, axes, and potentially other parameters such as faceting variable
level etc. This method must return a data.frame containing at least the
columns <code>PANEL</code>, <code>SCALE_X</code>, and <code>SCALE_Y</code> each containing
integer keys mapping a PANEL to which axes it should use. In addition the
data.frame can contain whatever other information is necessary to assign
observations to the correct panel as well as determining the position of
the panel.
</p>
</li>
<li> <p><code>map_data</code>: This method is supplied the data for each layer in
turn and is expected to supply a <code>PANEL</code> column mapping each row to a
panel defined in the layout. Additionally this method can also add or
subtract data points as needed e.g. in the case of adding margins to
<code>facet_grid()</code>.
</p>
</li>
<li> <p><code>draw_panels</code>: This is where the panels are assembled into a
<code>gtable</code> object. The method receives, among others, a list of grobs
defining the content of each panel as generated by the Geoms and Coord
objects. The responsibility of the method is to decorate the panels with
axes and strips as needed, as well as position them relative to each other
in a gtable. For some of the automatic functions to work correctly, each
panel, axis, and strip grob name must be prefixed with &quot;panel&quot;, &quot;axis&quot;, and
&quot;strip&quot; respectively.
</p>
</li></ul>

<p>In addition to the methods described above, it is also possible to override
the default behaviour of one or more of the following methods:
</p>

<ul>
<li> <p><code>setup_params</code>:
</p>
</li>
<li> <p><code>init_scales</code>: Given a master scale for x and y, create panel
specific scales for each panel defined in the layout. The default is to
simply clone the master scale.
</p>
</li>
<li> <p><code>train_scales</code>: Based on layer data train each set of panel
scales. The default is to train it on the data related to the panel.
</p>
</li>
<li> <p><code>finish_data</code>: Make last-minute modifications to layer data
before it is rendered by the Geoms. The default is to not modify it.
</p>
</li>
<li> <p><code>draw_back</code>: Add a grob in between the background defined by the
Coord object (usually the axis grid) and the layer stack. The default is to
return an empty grob for each panel.
</p>
</li>
<li> <p><code>draw_front</code>: As above except the returned grob is placed
between the layer stack and the foreground defined by the Coord object
(usually empty). The default is, as above, to return an empty grob.
</p>
</li>
<li> <p><code>draw_labels</code>: Given the gtable returned by <code>draw_panels</code>,
add axis titles to the gtable. The default is to add one title at each side
depending on the position and existence of axes.
</p>
</li></ul>

<p>All extension methods receive the content of the params field as the params
argument, so the constructor function will generally put all relevant
information into this field. The only exception is the <code>shrink</code>
parameter which is used to determine if scales are retrained after Stat
transformations has been applied.
</p>


<h3>Stats</h3>

<p>All <code style="white-space: pre;">stat_*()</code> functions (like <code>stat_bin()</code>) return a layer that
contains a <code style="white-space: pre;">Stat*</code> object (like <code>StatBin</code>). The <code style="white-space: pre;">Stat*</code>
object is responsible for rendering the data in the plot.
</p>
<p>Each of the <code style="white-space: pre;">Stat*</code> objects is a <code><a href="ggproto.html">ggproto()</a></code> object, descended
from the top-level <code>Stat</code>, and each implements various methods and
fields. To create a new type of Stat object, you typically will want to
override one or more of the following:
</p>

<ul>
<li><p> One of :
<code>compute_layer(self, data, scales, ...)</code>,
<code>compute_panel(self, data, scales, ...)</code>, or
<code>compute_group(self, data, scales, ...)</code>.
</p>
<p><code>compute_layer()</code> is called once per layer, <code>compute_panel_()</code>
is called once per panel, and <code>compute_group()</code> is called once per
group. All must return a data frame.
</p>
<p>It's usually best to start by overriding <code>compute_group</code>: if
you find substantial performance optimisations, override higher up.
You'll need to read the source code of the default methods to see
what else you should be doing.
</p>
<p><code>data</code> is a data frame containing the variables named according
to the aesthetics that they're mapped to. <code>scales</code> is a list
containing the <code>x</code> and <code>y</code> scales. There functions are called
before the facets are trained, so they are global scales, not local
to the individual panels.<code>...</code> contains the parameters returned by
<code>setup_params()</code>.
</p>
</li>
<li> <p><code>finish_layer(data, params)</code>: called once for each layer. Used
to modify the data after scales has been applied, but before the data is
handed of to the geom for rendering. The default is to not modify the
data. Use this hook if the stat needs access to the actual aesthetic
values rather than the values that are mapped to the aesthetic.
</p>
</li>
<li> <p><code>setup_params(data, params)</code>: called once for each layer.
Used to setup defaults that need to complete dataset, and to inform
the user of important choices. Should return list of parameters.
</p>
</li>
<li> <p><code>setup_data(data, params)</code>: called once for each layer,
after <code>setup_params()</code>. Should return modified <code>data</code>.
Default methods removes all rows containing a missing value in
required aesthetics (with a warning if <code>!na.rm</code>).
</p>
</li>
<li> <p><code>required_aes</code>: A character vector of aesthetics needed to
render the geom.
</p>
</li>
<li> <p><code>default_aes</code>: A list (generated by <code><a href="aes.html">aes()</a></code> of
default values for aesthetics.
</p>
</li></ul>



<h3>Positions</h3>

<p>All <code style="white-space: pre;">position_*()</code> functions (like <code>position_dodge()</code>) return a
<code style="white-space: pre;">Position*</code> object (like <code>PositionDodge</code>). The <code style="white-space: pre;">Position*</code>
object is responsible for adjusting the position of overlapping geoms.
</p>
<p>The way that the <code style="white-space: pre;">position_*</code> functions work is slightly different from
the <code style="white-space: pre;">geom_*</code> and <code style="white-space: pre;">stat_*</code> functions, because a <code style="white-space: pre;">position_*</code>
function actually &quot;instantiates&quot; the <code style="white-space: pre;">Position*</code> object by creating a
descendant, and returns that.
</p>
<p>Each of the <code style="white-space: pre;">Position*</code> objects is a <code><a href="ggproto.html">ggproto()</a></code> object,
descended from the top-level <code>Position</code>, and each implements the
following methods:
</p>

<ul>
<li> <p><code>compute_layer(self, data, params, panel)</code> is called once
per layer. <code>panel</code> is currently an internal data structure, so
this method should not be overridden.
</p>
</li>
<li> <p><code>compute_panel(self, data, params, scales)</code> is called once per
panel and should return a modified data frame.
</p>
<p><code>data</code> is a data frame containing the variables named according
to the aesthetics that they're mapped to. <code>scales</code> is a list
containing the <code>x</code> and <code>y</code> scales. There functions are called
before the facets are trained, so they are global scales, not local
to the individual panels. <code>params</code> contains the parameters returned by
<code>setup_params()</code>.
</p>
</li>
<li> <p><code>setup_params(data, params)</code>: called once for each layer.
Used to setup defaults that need to complete dataset, and to inform
the user of important choices. Should return list of parameters.
</p>
</li>
<li> <p><code>setup_data(data, params)</code>: called once for each layer,
after <code>setup_params()</code>. Should return modified <code>data</code>.
Default checks that required aesthetics are present.
</p>
</li></ul>

<p>And the following fields
</p>

<ul>
<li> <p><code>required_aes</code>: a character vector giving the aesthetics
that must be present for this position adjustment to work.
</p>
</li></ul>



<h3>Scales</h3>

<p>All <code style="white-space: pre;">scale_*</code> functions like <code><a href="scale_continuous.html">scale_x_continuous()</a></code> return a <code style="white-space: pre;">Scale*</code>
object like <code>ScaleContinuous</code>. Each of the <code style="white-space: pre;">Scale*</code> objects is a <code><a href="ggproto.html">ggproto()</a></code>
object, descended from the top-level <code>Scale</code>.
</p>
<p>Properties not documented in <code><a href="continuous_scale.html">continuous_scale()</a></code> or <code><a href="discrete_scale.html">discrete_scale()</a></code>:
</p>

<ul>
<li> <p><code>call</code> The call to <code><a href="continuous_scale.html">continuous_scale()</a></code> or <code><a href="discrete_scale.html">discrete_scale()</a></code> that constructed
the scale.
</p>
</li>
<li> <p><code>range</code> One of <code>continuous_range()</code> or <code>discrete_range()</code>.
</p>
</li></ul>

<p>Methods:
</p>

<ul>
<li> <p><code>is_discrete()</code> Returns <code>TRUE</code> if the scale is a discrete scale
</p>
</li>
<li> <p><code>is_empty()</code> Returns <code>TRUE</code> if the scale contains no information (i.e.,
it has no information with which to calculate its <code>limits</code>).
</p>
</li>
<li> <p><code>clone()</code> Returns a copy of the scale that can be trained
independently without affecting the original scale.
</p>
</li>
<li> <p><code>transform()</code> Transforms a vector of values using <code>self$trans</code>.
This occurs before the <code>Stat</code> is calculated.
</p>
</li>
<li> <p><code>train()</code> Update the <code>self$range</code> of observed (transformed) data values with
a vector of (possibly) new values.
</p>
</li>
<li> <p><code>reset()</code> Reset the <code>self$range</code> of observed data values. For discrete
position scales, only the continuous range is reset.
</p>
</li>
<li> <p><code>map()</code> Map transformed data values to some output value as
determined by <code>self$rescale()</code> and <code>self$palette</code> (except for position scales,
which do not use the default implementation of this method). The output corresponds
to the transformed data value in aesthetic space (e.g., a color, line width, or size).
</p>
</li>
<li> <p><code>rescale()</code> Rescale transformed data to the the range 0, 1. This is most useful for
position scales. For continuous scales, <code>rescale()</code> uses the <code>rescaler</code> that
was provided to the constructor. <code>rescale()</code> does not apply <code>self$oob()</code> to
its input, which means that discrete values outside <code>limits</code> will be <code>NA</code>, and
values that are outside <code>range</code> will have values less than 0 or greater than 1.
This allows guides more control over how out-of-bounds values are displayed.
</p>
</li>
<li> <p><code>transform_df()</code>, <code>train_df()</code>, <code>map_df()</code> These <code style="white-space: pre;">_df</code> variants
accept a data frame, and apply the <code>transform</code>, <code>train</code>, and <code>map</code> methods
(respectively) to the columns whose names are in <code>self$aesthetics</code>.
</p>
</li>
<li> <p><code>get_limits()</code> Calculates the final scale limits in transformed data space
based on the combination of <code>self$limits</code> and/or the range of observed values
(<code>self$range</code>).
</p>
</li>
<li> <p><code>get_breaks()</code> Calculates the final scale breaks in transformed data space
based on on the combination of <code>self$breaks</code>, <code>self$trans$breaks()</code> (for
continuous scales), and <code>limits</code>. Breaks outside of <code>limits</code> are assigned
a value of <code>NA</code> (continuous scales) or dropped (discrete scales).
</p>
</li>
<li> <p><code>get_labels()</code> Calculates labels for a given set of (transformed) <code>breaks</code>
based on the combination of <code>self$labels</code> and <code>breaks</code>.
</p>
</li>
<li> <p><code>get_breaks_minor()</code> For continuous scales, calculates the final scale minor breaks
in transformed data space based on the rescaled <code>breaks</code>, the value of <code>self$minor_breaks</code>,
and the value of <code>self$trans$minor_breaks()</code>. Discrete scales always return <code>NULL</code>.
</p>
</li>
<li> <p><code>make_title()</code> Hook to modify the title that is calculated during guide construction
(for non-position scales) or when the <code>Layout</code> calculates the x and y labels
(position scales).
</p>
</li></ul>

<p>These methods are only valid for position (x and y) scales:
</p>

<ul>
<li> <p><code>dimension()</code> For continuous scales, the dimension is the same concept as the limits.
For discrete scales, <code>dimension()</code> returns a continuous range, where the limits
would be placed at integer positions. <code>dimension()</code> optionally expands
this range given an expantion of length 4 (see <code><a href="expansion.html">expansion()</a></code>).
</p>
</li>
<li> <p><code>break_info()</code> Returns a <code>list()</code> with calculated values needed for the <code>Coord</code>
to transform values in transformed data space. Axis and grid guides also use
these values to draw guides. This is called with
a (usually expanded) continuous range, such as that returned by <code>self$dimension()</code>
(even for discrete scales). The list has components <code>major_source</code>
(<code>self$get_breaks()</code> for continuous scales, or <code>seq_along(self$get_breaks())</code>
for discrete scales), <code>major</code> (the rescaled value of <code>major_source</code>, ignoring
<code>self$rescaler</code>), <code>minor</code> (the rescaled value of <code>minor_source</code>, ignoring
<code>self$rescaler</code>), <code>range</code> (the range that was passed in to <code>break_info()</code>),
<code>labels</code> (the label values, one for each element in <code>breaks</code>).
</p>
</li>
<li> <p><code>axis_order()</code> One of <code>c("primary", "secondary")</code> or <code>c("secondary", "primary")</code>
</p>
</li>
<li> <p><code>make_sec_title()</code> Hook to modify the title for the second axis that is calculated
when the <code>Layout</code> calculates the x and y labels.
</p>
</li></ul>



<h3>See Also</h3>

<p>ggproto
</p>

<hr /><div style="text-align: center;">[Package <em>ggplot2</em> version 3.3.5 <a href="00Index.html">Index</a>]</div>
</body></html>
