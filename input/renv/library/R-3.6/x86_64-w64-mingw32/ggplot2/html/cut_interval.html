<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Discretise numeric data into categorical</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for cut_interval {ggplot2}"><tr><td>cut_interval {ggplot2}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Discretise numeric data into categorical</h2>

<h3>Description</h3>

<p><code>cut_interval()</code> makes <code>n</code> groups with equal range, <code>cut_number()</code>
makes <code>n</code> groups with (approximately) equal numbers of observations;
<code>cut_width()</code> makes groups of width <code>width</code>.
</p>


<h3>Usage</h3>

<pre>
cut_interval(x, n = NULL, length = NULL, ...)

cut_number(x, n = NULL, ...)

cut_width(
  x,
  width,
  center = NULL,
  boundary = NULL,
  closed = c("right", "left"),
  ...
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p>number of intervals to create, OR</p>
</td></tr>
<tr valign="top"><td><code>length</code></td>
<td>
<p>length of each interval</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>

<p>Arguments passed on to <code><a href="../../base/html/cut.html">base::cut.default</a></code>
</p>

<dl>
<dt><code>breaks</code></dt><dd><p>either a numeric vector of two or more unique cut points or a
single number (greater than or equal to 2) giving the number of
intervals into which <code>x</code> is to be cut.</p>
</dd>
<dt><code>labels</code></dt><dd><p>labels for the levels of the resulting category.  By default,
labels are constructed using <code>"(a,b]"</code> interval notation.  If
<code>labels = FALSE</code>, simple integer codes are returned instead of
a factor.</p>
</dd>
<dt><code>right</code></dt><dd><p>logical, indicating if the intervals should be closed on
the right (and open on the left) or vice versa.</p>
</dd>
<dt><code>dig.lab</code></dt><dd><p>integer which is used when labels are not given.  It
determines the number of digits used in formatting the break numbers.</p>
</dd>
<dt><code>ordered_result</code></dt><dd><p>logical: should the result be an ordered factor?</p>
</dd>
</dl>
</td></tr>
<tr valign="top"><td><code>width</code></td>
<td>
<p>The bin width.</p>
</td></tr>
<tr valign="top"><td><code>center, boundary</code></td>
<td>
<p>Specify either the position of edge or the center of
a bin. Since all bins are aligned, specifying the position of a single bin
(which doesn't need to be in the range of the data) affects the location of
all bins. If not specified, uses the &quot;tile layers algorithm&quot;, and sets
the boundary to half of the binwidth.
</p>
<p>To center on integers, <code>width = 1</code> and <code>center = 0</code>.
<code>boundary = 0.5</code>.</p>
</td></tr>
<tr valign="top"><td><code>closed</code></td>
<td>
<p>One of <code>"right"</code> or <code>"left"</code> indicating whether right
or left edges of bins are included in the bin.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Randall Prium contributed most of the implementation of
<code>cut_width()</code>.
</p>


<h3>Examples</h3>

<pre>
table(cut_interval(1:100, 10))
table(cut_interval(1:100, 11))

table(cut_number(runif(1000), 10))

table(cut_width(runif(1000), 0.1))
table(cut_width(runif(1000), 0.1, boundary = 0))
table(cut_width(runif(1000), 0.1, center = 0))
table(cut_width(runif(1000), 0.1, labels = FALSE))
</pre>

<hr /><div style="text-align: center;">[Package <em>ggplot2</em> version 3.3.5 <a href="00Index.html">Index</a>]</div>
</body></html>
