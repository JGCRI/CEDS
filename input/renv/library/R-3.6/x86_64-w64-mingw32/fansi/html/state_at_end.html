<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Utilities for Managing CSI and OSC State In Strings</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for state_at_end {fansi}"><tr><td>state_at_end {fansi}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Utilities for Managing CSI and OSC State  In Strings</h2>

<h3>Description</h3>

<p><code>state_at_end</code> reads through strings computing the accumulated SGR and
OSC hyperlinks, and outputs the active state at the end of them.
<code>close_state</code> produces the sequence that closes any SGR active and OSC
hyperlinks at the end of each input string.  If <code>normalize = FALSE</code>
(default), it will emit the reset code &quot;ESC[0m&quot; if any SGR is present.
It is more interesting for closing SGRs if <code>normalize = TRUE</code>.  Unlike
<code>state_at_end</code> and other functions <code>close_state</code> has no concept of <code>carry</code>:
it will only emit closing sequences for states explicitly active at the end
of a string.
</p>


<h3>Usage</h3>

<pre>
state_at_end(
  x,
  warn = getOption("fansi.warn", TRUE),
  term.cap = getOption("fansi.term.cap", dflt_term_cap()),
  normalize = getOption("fansi.normalize", FALSE),
  carry = getOption("fansi.carry", FALSE)
)

close_state(
  x,
  warn = getOption("fansi.warn", TRUE),
  normalize = getOption("fansi.normalize", FALSE)
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>a character vector or object that can be coerced to such.</p>
</td></tr>
<tr valign="top"><td><code>warn</code></td>
<td>
<p>TRUE (default) or FALSE, whether to warn when potentially
problematic <em>Control Sequences</em> are encountered.  These could cause the
assumptions <code>fansi</code> makes about how strings are rendered on your display
to be incorrect, for example by moving the cursor (see <code><a href="fansi.html">?fansi</a></code>).
At most one warning will be issued per element in each input vector.  Will
also warn about some badly encoded UTF-8 strings, but a lack of UTF-8
warnings is not a guarantee of correct encoding (use <code><a href="../../base/html/validUTF8.html">validUTF8</a></code> for
that).</p>
</td></tr>
<tr valign="top"><td><code>term.cap</code></td>
<td>
<p>character a vector of the capabilities of the terminal, can
be any combination of &quot;bright&quot; (SGR codes 90-97, 100-107), &quot;256&quot; (SGR codes
starting with &quot;38;5&quot; or &quot;48;5&quot;), &quot;truecolor&quot; (SGR codes starting with
&quot;38;2&quot; or &quot;48;2&quot;), and &quot;all&quot;. &quot;all&quot; behaves as it does for the <code>ctl</code>
parameter: &quot;all&quot; combined with any other value means all terminal
capabilities except that one.  <code>fansi</code> will warn if it encounters SGR codes
that exceed the terminal capabilities specified (see <code><a href="term_cap_test.html">term_cap_test</a></code>
for details).  In versions prior to 1.0, <code>fansi</code> would also skip exceeding
SGRs entirely instead of interpreting them.  You may add the string &quot;old&quot;
to any otherwise valid <code>term.cap</code> spec to restore the pre 1.0 behavior.
&quot;old&quot; will not interact with &quot;all&quot; the way other valid values for this
parameter do.</p>
</td></tr>
<tr valign="top"><td><code>normalize</code></td>
<td>
<p>TRUE or FALSE (default) whether SGR sequence should be
normalized out such that there is one distinct sequence for each SGR code.
normalized strings will occupy more space (e.g. &quot;\033[31;42m&quot; becomes
&quot;\033[31m\033[42m&quot;), but will work better with code that assumes each SGR
code will be in its own escape as <code>crayon</code> does.</p>
</td></tr>
<tr valign="top"><td><code>carry</code></td>
<td>
<p>TRUE, FALSE (default), or a scalar string, controls whether to
interpret the character vector as a &quot;single document&quot; (TRUE or string) or
as independent elements (FALSE).  In &quot;single document&quot; mode, active state
at the end of an input element is considered active at the beginning of the
next vector element, simulating what happens with a document with active
state at the end of a line.  If FALSE each vector element is interpreted as
if there were no active state when it begins.  If character, then the
active state at the end of the <code>carry</code> string is carried into the first
element of <code>x</code> (see &quot;Replacement Functions&quot; for differences there).  The
carried state is injected in the interstice between an imaginary zeroeth
character and the first character of a vector element.  See the &quot;Position
Semantics&quot; section of <code><a href="substr_ctl.html">substr_ctl</a></code> and the &quot;State Interactions&quot; section
of <code><a href="fansi.html">?fansi</a></code> for details.  Except for <code><a href="strwrap_ctl.html">strwrap_ctl</a></code> where <code>NA</code> is
treated as the string <code>"NA"</code>, <code>carry</code> will cause <code>NA</code>s in inputs to
propagate through the remaining vector elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector same length as <code>x</code>.
</p>


<h3>Control and Special Sequences</h3>

<p><em>Control Sequences</em> are non-printing characters or sequences of characters.
<em>Special Sequences</em> are a subset of the <em>Control Sequences</em>, and include CSI
SGR sequences which can be used to change rendered appearance of text, and
OSC hyperlinks.  See <code><a href="fansi.html">fansi</a></code> for details.
</p>


<h3>Output Stability</h3>

<p>Several factors could affect the exact output produced by <code>fansi</code>
functions across versions of <code>fansi</code>, <code>R</code>, and/or across systems.
<strong>In general it is best not to rely on exact <code>fansi</code> output, e.g. by
embedding it in tests</strong>.
</p>
<p>Width and grapheme calculations depend on locale, Unicode database
version, and grapheme processing logic (which is still in development), among
other things.  For the most part <code>fansi</code> (currently) uses the internals of
<code>base::nchar(type='width')</code>, but there are exceptions and this may change in
the future.
</p>
<p>How a particular display format is encoded in <em>Control Sequences</em> is
not guaranteed to be stable across <code>fansi</code> versions.  Additionally, which
<em>Special Sequences</em> are re-encoded vs transcribed untouched may change.
In general we will strive to keep the rendered appearance stable.
</p>
<p>To maximize the odds of getting stable output set <code>normalize_state</code> to
<code>TRUE</code> and <code>type</code> to <code>"chars"</code> in functions that allow it, and
set <code>term.cap</code> to a specific set of capabilities.
</p>


<h3>See Also</h3>

<p><code><a href="fansi.html">?fansi</a></code> for details on how <em>Control Sequences</em> are
interpreted, particularly if you are getting unexpected results,
<code><a href="unhandled_ctl.html">unhandled_ctl</a></code> for detecting bad control sequences.
</p>


<h3>Examples</h3>

<pre>
x &lt;- c("\033[44mhello", "\033[33mworld")
state_at_end(x)
state_at_end(x, carry=TRUE)
(close &lt;- close_state(state_at_end(x, carry=TRUE), normalize=TRUE))
writeLines(paste0(x, close, " no style"))
</pre>

<hr /><div style="text-align: center;">[Package <em>fansi</em> version 1.0.2 <a href="00Index.html">Index</a>]</div>
</body></html>
